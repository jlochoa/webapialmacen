Crear proyecto

Elegir plantilla de proyecto Webapi, dar un nombre al proyecto y dejar las opciones por defecto.
Eliminar el archivo WeatherForecast.cs y el controller WeatherForecastController

Crear la base de datos MiAlmacen con estos scripts
CREATE TABLE Familias (
  Id              INT           NOT NULL    IDENTITY    PRIMARY KEY,
  Nombre           NVARCHAR(100)  NOT NULL
);

CREATE TABLE Productos (
    Id              INT           NOT NULL    IDENTITY    PRIMARY KEY,
    Nombre        NVARCHAR (150) NOT NULL,
    Precio        DECIMAL (9, 2) NOT NULL,
    FechaAlta     DATE           NULL,
    Descatalogado BIT            NOT NULL,
    FotoURL       NVARCHAR (MAX) NULL,
    FamiliaId     INT            NOT NULL,
    CONSTRAINT FK_Familias_Productos FOREIGN KEY (FamiliaId) REFERENCES Familias (Id)
);

Agregar los paquetes necesarios a la aplicación desde Herramientas, Administrador de paquetes Nuget.
Instalar estos paquetes:
Microsoft.EntityFrameworkCore.SqlServer 
Microsoft.EntityFrameworkCore.Tools 

-----------------------------------------------------------------------------------------------------------
Crear los modelos mediante Scaffold
Ejecutar el siguiente comando desde la consola de paquetes Nuget
Scaffold-DbContext "Data Source=localhost;Initial Catalog=MiAlmacen;Integrated Security=True;TrustServerCertificate=true" -Provider Microsoft.EntityFrameworkCore.SqlServer -OutputDir Models -force -project WebAPIAlmacen

Debemos sustituir el valor de Data Source por la configuración de nuestro servidor
Al ejecutarse el comando se crea la carpeta Models con los modelos de datos y MiAlmacenContext con la configuración y estructura de la base de datos
-----------------------------------------------------------------------------------------------------------
Crear controller de Familias

En el archivo appsettings.development.json ponemos la cadena de conexión de la base de datos
En el program registramos la conexión leyendo la cadena de conexión anterior y creando un context que pueda inyectarse
en otras clases, normalmente controllers y/o servicios
Creamos el controller de familias en la carpeta controller. Es MUY IMPORTANTE que cada controller tenga el sufijo controller
En cada controller, inyectamos como dependencia el context (MiAlmacenContext) para poder utilizar la base de datos
-----------------------------------------------------------------------------------------------------------
Desarrollar controller de Familias

Cada punto de acceso del controller:
    Es un método debe ir precedido de el tipo de petición (Get, Post, Put o Delete habitualmente)
    Debe ser asíncrono async Task y preferiblemete devolver un ActionResult para, además de la información, devolver el código de retorno,
    por ejemplo, un Ok 200 cuando va todo bien o un Bad Request 400 cuando hay algún fallo
    Al ser asíncrono, cada operación del context debe precederse por un await e incluir un método que contenga Async
    Cada uno de los puntos de acceso debe tener una ruta diferente (por ejemplo, no puede haber dos [HttpGet], el segundo incluiría una ruta)
    También puede haber argumentos. Estos argumentos son los que el punto de acceso necesitará para programar su lógica
    Estos argumentos van entre paréntesis junto al nombre del método y deben coincidir en su nombre con los argumentos expuestos en la ruta
    Por defecto, los argumentos se toman de la ruta ([FromRoute]). Si viene con sintaxis querystring van con [FromQuery] y si
    vienen con archivos con [FromForm]

    Opcionalmente, podemos tener en cuenta ajustar el tracking en la aplicación. Para ello, en el Program debemos deshabilitarlo
    y en los controladores, activar el tracking en las operaciones necesarias (modificaciones de datos)

------------------------------------------------------------------------------------------------------------
Servicios
Un servicio centraliza operaciones que de forma reiterada vamos a necesitar en el proyecto
Lo habitual es crear una carpeta Services e ir creando los servicios dentro
Cada servicio es una clase autónoma en cuyo constructor se registran las dependencias que necesita
Una vez desarrollado, se registra en el program. Después, en los controllers donde se usa se debe inyectar como
dependencia de la misma manera que lo hacemos con el context

------------------------------------------------------------------------------------------------------------
Servicios con interfaces

Como buena práctica, se pueden crear interfaces como especificaciones para los servicios. Si hacemos esto,
en el program el servicio se debe registrar a partir de la interface y en cada controller el servicio se debe
registrar haciendo referencia a la interface

------------------------------------------------------------------------------------------------------------
Servicios para tareas programadas
Estos servicios son Singleton porque solo se ejecuta una instancia de estos en el servidor. Para desarrollar
este tipo de servicios, estas clases deben heredar de IHostedService y en el program se deben registrar mediante
el método AddHostedService

Estos servicios se construyen siempre igual, siendo el método StartAsync el que se ejecuta de forma automática al
iniciarse el servicio y el StopAsync el que se ejecuta al finalizar el servicio. En ambos métodos programaríamos la
lógica del servicio

------------------------------------------------------------------------------------------------------------
Middlewares

Los Middlewares son procesos que se ejecutan uno tras otro tras llegar una petición al servidor. Los distinguimos en el program
por su prefijo use. Muchos tienen lógica ya predefinida y otros los podemos desarrollar nosotros.
Cuando necesitamos desarrollar uno, creamos una clase en una ubicación, habitualmente una carpeta Middlewares, inyectamos
como dependencia de la clase RequestDelegate e incluimos el método InvokeAsync. Este método ya viene con la información de la 
petición (HttpContext). Dentro del InvokeAsync programamos la lógica del Middleware. Podemos analizar, rechazar e incluso
transformar una petición. Si decidimos que la petición debe continuar, especificamos que debe proseguir con el siguiente
middleware (next(httpContext))

------------------------------------------------------------------------------------------------------------
Filtros

Los filtros son procesos que se ejecutan tras los middlewares. Pueden servir, por ejemplo, como filtros de autorización 
para examinar si un usuario puede acceder a determinados puntos de acceso. También nos pueden servir para controlar
de forma global excepciones. Este es el llamado filtro de excepción. Los filtros son clases que suelen ir en una carpeta Filters
El filtro de excepción es una clase que hereda de ExceptionFilterAttribute. El método OnException viene ya con la información de la excepción.
Será en este método donde programemos la respuesta común a todas las excepciones.
En el program, los filtros hay que registrarlos en el método AddControllers

------------------------------------------------------------------------------------------------------------
CORS

Para especificar una cors policy que controle a nivel general el tipo de peticiones que se aceptan y desde donde,
simplemente debemos especificar en el Program estas características y emplear el middleware UseCors

------------------------------------------------------------------------------------------------------------
Procedimientos almacenados

Incluir los siguientes procedimientos almacenados agregando consultas a la base de datos

CREATE PROCEDURE Familias_Insertar
                @nombre nvarchar(150),
                @id int OUTPUT
                AS
                BEGIN
                SET NOCOUNT ON;
                INSERT INTO Familias(Nombre)
                VALUES (@nombre);
                SELECT @id = SCOPE_IDENTITY();
                END


CREATE PROCEDURE Familias_ObtenerPorId
                @id int
                AS
                BEGIN
                SET NOCOUNT ON;
                SELECT *
                FROM Familias
                WHERE Id = @id;
                END

En FamiliasController abrimos puntos de acceso (un post y un get) para poder ejecutarlos




------------------------------------------------------------------------------------------------------------
SEGURIDAD

Creamos la tabla de usuarios y hacemos el Scaffold

CREATE TABLE [dbo].[Usuarios]
(
	[Id] INT NOT NULL PRIMARY KEY IDENTITY, 
    [Email] NVARCHAR(100) NOT NULL, 
    [Password] NVARCHAR(500) NOT NULL, 
    [Salt] VARBINARY(MAX) NULL
)

------------------------------------------------------------------------------------------------------------
Encriptación de doble vía

Ponemos una clave de encriptación en la configuración (appsettings)

  "ClaveEncriptacion": "123Curso2022321"

Creamos una clase DTOUsuario en la carpeta DTO para recibir la información en el controller de usuarios
Habilitamos en el Program la encriptación de doble vía:
builder.Services.AddDataProtection();

Ponemos los métodos de creación y autenticación de usuarios en el controller de Usuarios inyectando las dependencias necesarias

 public class UsuariosController : ControllerBase
    {

        private readonly MiAlmacenContext context;
        private readonly IConfiguration configuration;
        private readonly IDataProtector dataProtector;
        public UsuariosController(MiAlmacenContext context, IConfiguration configuration, IDataProtectionProvider dataProtectionProvider)
        {
            this.context = context;
            this.configuration = configuration;
            dataProtector = dataProtectionProvider.CreateProtector(configuration["ClaveEncriptacion"]);
        }

        [HttpPost("encriptar/nuevousuario")]
        public async Task<ActionResult> PostNuevoUsuario([FromBody] DTOUsuario usuario)
        {
            var passEncriptado = dataProtector.Protect(usuario.Password);
            var newUsuario = new Usuario
            {
                Email = usuario.Email,
                Password = passEncriptado
            };
            await context.Usuarios.AddAsync(newUsuario);
            await context.SaveChangesAsync();

            return Ok(newUsuario);
        }

        [HttpPost("encriptar/checkusuario")]
        public async Task<ActionResult> PostCheckUserPassEncriptado([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return Unauthorized();
            }

            var passDesencriptado = dataProtector.Unprotect(usuarioDB.Password);
            if (usuario.Password == passDesencriptado)
            {
                return Ok();
            }
            else
            {
                return Unauthorized();
            }
        }

    }

------------------------------------------------------------------------------------------------------------
Encriptación de una vía (hash)

En una clase ResultadoHash especificamos el tipo de información que utilizarán el controller de usuarios
y el servicio de encriptación.
La encriptación la vamos a incluir en un servicio para poder reutiizarla o incluso llevarla a otro proyecto.
El servicio es HashService

    public class HashService
    {
        // Un hash es una clave que no se puede revertir. Es lo correcto para contraseñas seguras
        // El hash es lo que se guardará en la tabla de usuarios.
        // Las funciones que generan hash también nos van a servir para contrastarlos
        // Un salt es un valor aleatorio que se anexa al texto plano al que queremos aplicar la función que genera el hash
        // Añade más seguridad porque, uniendo un salt aleatorio al password, los valores siempre serán diferentes
        // Si generamos el password sin salt, basándonos solo en el password (que es solo un texto plano) los hashes generados basados en ese password siempre serán iguales
        // El salt se debe guardar junto al password para contrastar el login

        // Método para generar el salt
        public ResultadoHash Hash(string textoPlano)
        {
            // Generamos el salt aleatorio
            var salt = new byte[16];
            using (var random = RandomNumberGenerator.Create())
            {
                random.GetBytes(salt); // Genera un array aleatorio de bytes
            }

            // Llamamos al método ResultadoHash y retornamos el hash con el salt
            return Hash(textoPlano, salt);
        }


        public ResultadoHash Hash(string textoPlano, byte[] salt)
        {
            //Pbkdf2 es un algoritmo de encriptación
            var claveDerivada = KeyDerivation.Pbkdf2(password: textoPlano,
                salt: salt, prf: KeyDerivationPrf.HMACSHA1,
                iterationCount: 10000,
                numBytesRequested: 32);

            var hash = Convert.ToBase64String(claveDerivada);

            return new ResultadoHash()
            {
                Hash = hash,
                Salt = salt
            };
        }
    }

El servicio hay que registrarlo en el program

builder.Services.AddTransient<HashService>();

Y luego, en el controller, empleamos el servicio para crear un usuario y ver si existe
 private readonly AlmacenContext context;
        private readonly IConfiguration configuration;
        private readonly IHashService hashService;
        private readonly AlmacenContext context;
        private readonly IDataProtector dataProtector;
        public UsuariosController(AlmacenContext context, IConfiguration configuration, IDataProtectionProvider dataProtectionProvider, IHashService hashService)
        {
            this.context = context;
            this.configuration = configuration;
            this.hashService = hashService;
            dataProtector = dataProtectionProvider.CreateProtector(configuration["ClaveEncriptacion"]);
        }
...

[HttpPost("hash/nuevousuario")]
        public async Task<ActionResult> PostNuevoUsuarioHash([FromBody] DTOUsuario usuario)
        {
            var resultadoHash = hashService.Hash(usuario.Password);
            var newUsuario = new Usuario
            {
                Email = usuario.Email,
                Password = resultadoHash.Hash,
                Salt = resultadoHash.Salt
            };

            await context.Usuarios.AddAsync(newUsuario);
            await context.SaveChangesAsync();

            return Ok(newUsuario);
        }

        [HttpPost("hash/checkusuario")]
        public async Task<ActionResult> CheckUsuarioHash([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return Unauthorized();
            }

            var resultadoHash = hashService.Hash(usuario.Password,usuarioDB.Salt);
            if (usuarioDB.Password == resultadoHash.Hash)
            {
                return Ok();
            }
            else
            {
                return Unauthorized();
            }

        }


---------------------------------------------------------------------------------------------
JWT

Para devolver un token de acceso a los usuarios autenticados, establecemos una clave de firma en la configuración del proyecto:

 "ClaveJWT": "Curso@.net#2024_Talio"

Creamos una clase para manejar la información que devolveremos al usuario autenticado (DTOLoginResponse)
Y en un punto de acceso del controller de usuarios gestionamos el login

  [HttpPost("login")]
        public async Task<ActionResult> Login([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return BadRequest();
            }

            var resultadoHash = hashService.Hash(usuario.Password, usuarioDB.Salt);
            if (usuarioDB.Password == resultadoHash.Hash)
            {
                var response = GenerarToken(usuario);
                return Ok(response);
            }
            else
            {
                return BadRequest();
            }
        }

        [Authorize(AuthenticationSchemes = JwtBearerDefaults.AuthenticationScheme)]
        [HttpPost("renovartoken")]
        public async Task<ActionResult> RenovarToken([FromBody] DTOUsuario usuario)
        {
            var usuarioDB = await context.Usuarios.FirstOrDefaultAsync(x => x.Email == usuario.Email);
            if (usuarioDB == null)
            {
                return BadRequest();
            }

            var response = GenerarToken(usuario);
            return Ok(response);
        }

        private DTOLoginResponse GenerarToken(DTOUsuario credencialesUsuario)
        {
            var claims = new List<Claim>()
            {
                new Claim(ClaimTypes.Email, credencialesUsuario.Email),
                new Claim("lo que yo quiera", "cualquier otro valor")
            };

            var clave = configuration["ClaveJWT"];
            var claveKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(clave));
            var signinCredentials = new SigningCredentials(claveKey, SecurityAlgorithms.HmacSha256);

            var securityToken = new JwtSecurityToken(
                claims: claims,
                expires:DateTime.Now.AddDays(30),
                signingCredentials: signinCredentials
            );

            
            var tokenString = new JwtSecurityTokenHandler().WriteToken(securityToken);

            return new DTOLoginResponse()
            {
                Token = tokenString,
                Email = credencialesUsuario.Email
            };
        }

Configuramos la autenticación en el Program

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
               .AddJwtBearer(options => options.TokenValidationParameters = new TokenValidationParameters
               {
                   ValidateIssuer = false,
                   ValidateAudience = false,
                   ValidateLifetime = true,
                   ValidateIssuerSigningKey = true,
                   IssuerSigningKey = new SymmetricSecurityKey(
                     Encoding.UTF8.GetBytes(builder.Configuration["ClaveJWT"]))
               });


builder.Services.AddSwaggerGen(c =>
{
    c.AddSecurityDefinition("Bearer", new OpenApiSecurityScheme
    {
        Name = "Authorization",
        Type = SecuritySchemeType.ApiKey,
        Scheme = "Bearer",
        BearerFormat = "JWT",
        In = ParameterLocation.Header
    });

    c.AddSecurityRequirement(new OpenApiSecurityRequirement
                {
                    {
                        new OpenApiSecurityScheme
                        {
                            Reference = new OpenApiReference
                            {
                                Type = ReferenceType.SecurityScheme,
                                Id = "Bearer"
                            }
                        },
                        new string[]{}
                    }
                });

});

Incluimos la anotación Authorize en el controller que queramos o en los métodos
También podemos habilitar algún método con [AllowAnonymous]

Desde Swagger, debemos ver un botón verde Authorize para poder incluir un token. 
Al darle, ponemos Bearer y después pegamos el token



---------------------------------------------------------------------------------------------
Serilog

Instalamos estos paquetes. A día de hoy el paquete Serilog.Sinks.MSSqlServer en su versión 6.6.1

Serilog.AspNetCore
Serilog.Settings.Configuration
Serilog.Sinks.MSSqlServer

Agregamos en el app.settings.Development la configuración de serilog

 "Serilog": {
    "MinimumLevel": "Information",
    "WriteTo": [
      {
        "Name": "MSSqlServer",
        "Args": {
          "connectionString": "Data Source=localhost;Initial Catalog=MiAlmacen;Integrated Security=True;TrustServerCertificate=true",
          "tableName": "Logs",
          "autoCreateSqlTable": true
        }
      }
    ]
  }

  Y en el Program registramos serilog para que de forma automática vaya anotando la actividad.
  En este caso, el nivel de log es information y lo guardará en una tabla Logs de nuestra base de datos
  Los diferentes niveles de log son: Critical, Error, Warning, Information, Debug y Trace

----------------------------------------------------------------------------------------------
Logs

Mediante ILogger podemos hacer que un controller emita mensajes personalizados
Hay que inyectar la dependencia en el controller y luego registrar los mensajes de log allá donde queramos,
por ejemplo así:

  logger.LogInformation(usuario.Email + " ha iniciado un login el día " +
    DateTime.Now);  

----------------------------------------------------------------------------------------------
ANGULAR

Creamos proyecto Angular, instalamos dependencias

ng new AngularAlmacen 

npm install bootstrap 
npm install primeng@16.4.4 
npm install primeicons

En el archivo angular.json integramos estilos y scripts de primeng y bootstrap

"styles": [
              "node_modules/bootstrap/dist/css/bootstrap.min.css",
              "node_modules/primeng/resources/themes/lara-light-blue/theme.css",
              "node_modules/primeng/resources/primeng.min.css",
              "node_modules/primeicons/primeicons.css"
            ],
            "scripts": [
              "node_modules/bootstrap/dist/js/bootstrap.bundle.min.js"
            ]


Creamos módulos y componentes para la aplicación

ng g m inicio

ng g c inicio/login --skip-tests=true
ng g c inicio/notFound --skip-tests=true
ng g m almacen
ng g c almacen/almacen -s --flat --skip-tests=true
ng g c almacen/categorias --skip-tests=true
ng g c almacen/productos --skip-tests=true
ng g s almacen/almacen --skip-tests=true

Creamos archivo de rutas app-routing.module.ts

import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { LoginComponent } from './inicio/login/login.component';
import { NotFoundComponent } from './inicio/not-found/not-found.component';

const appRoutes: Routes = [
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: 'login', component: LoginComponent },
  {
    path: 'almacen',
    loadChildren: () => import('./almacen/almacen.module').then((m) => m.AlmacenModule)
  },
  { path: '**', component: NotFoundComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}

Creamos el enrutamiento para el módulo de almacén
import { NgModule } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenComponent } from './almacen.component';

const appRoutes: Routes = [
  {
    path: '',
    component: AlmacenComponent,
    children: [
      { path: '', redirectTo: '/almacen/categorias', pathMatch: 'full' },
      { path: 'categorias', component: CategoriasComponent },
      { path: 'productos', component: ProductosComponent }
    ]
  }
];

@NgModule({
  imports: [RouterModule.forChild(appRoutes)],
  exports: [RouterModule]
})
export class AlmacenRoutingModule {}


Cambiamos el módulo almacén

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenComponent } from './almacen.component';
import { AlmacenService } from './almacen.service';
import { AlmacenRoutingModule } from './almacen-routing.module';

@NgModule({
  declarations: [CategoriasComponent, ProductosComponent, AlmacenComponent],
  imports: [CommonModule, AlmacenRoutingModule],
  providers: [AlmacenService]
})
export class AlmacenModule {}

Cambiamos el app.component.html

<h1>Gestión almacén</h1>
<hr/>
<router-outlet></router-outlet>

Cambiamos el almacen.component.html

<h1>Gestión almacén</h1>
<hr/>
<router-outlet></router-outlet>

Cambiamos el módulo principal app.module para incluir el sistema de rutas y el módulo HttpClientModule

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

import { AppComponent } from './app.component';
import { AppRoutingModule } from './app-routing.module';
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule, BrowserAnimationsModule, HttpClientModule, AppRoutingModule],
  bootstrap: [AppComponent]
})
export class AppModule {}

Cambiamos el html y el css del not-found.component

 <div class="row">
  <div class="col">
    <img src="https://www.seekahost.com/wp-content/uploads/2017/11/404-page-not-found.jpg" class="img-fluid" />
  </div>
</div>

img {
  height: 100%;
  width: 100%;
}

----------------------------------------------------------------------------------------------
Autenticación

Creamos las interfaces en una carpeta interfaces

export interface ILogin {
  email: string;
  password: string;
}

export interface ILoginResponse {
  email: string;
  token: string;
}

Creamos servicio de autenticación y servicio vigilante (guard)
ng g s services/app --skip-tests=true
ng g s guards/authGuard --skip-tests=true

Generar archivos de variables de entorno
ng generate environments

environment.development.json (cambiar el puerto si es necesario)
export const environment = {
    urlAPI: 'https://localhost:7127/api/'
};


Desarrollar el servicio de autenticación

app.service.ts

import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { HttpClient } from '@angular/common/http';
import { environment } from 'src/environments/environment';
import { ILogin, ILoginResponse } from '../interfaces/login.interface';

@Injectable({
  providedIn: 'root'
})
export class AppService {
  urlAPI: string;

  constructor(private http: HttpClient) {
    this.urlAPI = environment.urlAPI;
  }

  login(credenciales: ILogin): Observable<ILoginResponse> {
    return this.http.post<ILoginResponse>(`${this.urlAPI}usuarios/login`, credenciales);
  }
}

Modificamos el módulo de inicio agregando el módulo de formularios y el ToastModule de Primeng para los mensajes del componente login

inicio.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { LoginComponent } from './login/login.component';
import { NotFoundComponent } from './not-found/not-found.component';
import { FormsModule } from '@angular/forms';
import { ToastModule } from 'primeng/toast';


@NgModule({
  declarations: [
    LoginComponent,
    NotFoundComponent
  ],
  imports: [
    CommonModule,FormsModule,ToastModule
  ]
})
export class InicioModule { }

Desarrollamos el componente login

login.component.html

<div class="text-center">
  <form class="form-signin" #fLogin="ngForm" (submit)="login()">
    <img class="mb-4" src="https://s3-eu-west-1.amazonaws.com/tpd/logos/5be01d787b5e5b0001ebb6bb/0x0.png" alt="login"
      width="72" height="72">
    <h1 class="h3 mb-3 font-weight-normal">Login</h1>
    <div class="form-group">
      <label for="email" class="sr-only">Usuario</label>
      <input type="email" class="form-control" placeholder="Email" [(ngModel)]="infoLogin.email" name="email" id="email"
        required>
    </div>
    <div class="form-group">
      <label for="password" class="sr-only">Password</label>
      <input type="password" class="form-control" placeholder="Contraseña" name="password" id="password"
        [(ngModel)]="infoLogin.password" required>
    </div>
    <button class="btn btn-primary" type="submit" [hidden]="!fLogin.valid">Login</button>
    <button class="btn btn-primary" type="submit" [hidden]="fLogin.valid" [disabled]="!fLogin.valid"
      style="cursor:not-allowed">Login</button>
    <p class="mt-5 mb-3 text-muted">Curso Angular 2024</p>
  </form>
  <p-toast></p-toast>
</div>


login.component.ts

import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { MessageService } from 'primeng/api';
import { AuthGuard } from 'src/app/guards/auth-guard.service';
import { ILogin, ILoginResponse } from 'src/app/interfaces/login.interface';
import { AppService } from 'src/app/services/app.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css'],
  providers: [MessageService]
})
export class LoginComponent implements OnInit {
  infoLogin: ILogin = {
    email: '',
    password: ''
  };

  constructor(
    private router: Router,
    private appService: AppService,
    private messageService: MessageService,
    private authGuard: AuthGuard
  ) {}

  ngOnInit() {
    if (this.authGuard.isLoggedIn()) {
      this.router.navigateByUrl('almacen/categorias');
    }
  }

  login() {
    this.appService.login(this.infoLogin).subscribe({
      next: (data) => {
        // const infoUser: ILoginResponse = {
        //   email: data.email,
        //   token: data.token
        // };
        sessionStorage.setItem('usuario', JSON.stringify(data));
        //  this.router.navigateByUrl('almacen');
        this.router.navigate([`/almacen`], { replaceUrl: true });
      },
      error: (err) => {
        this.messageService.add({ severity: 'error', summary: 'Error', detail: 'Credenciales erróneas' });
      }
    });
  }
}


login.component.css

html,
body {
  height: 100%;
}

body {
  display: -ms-flexbox;
  display: flex;
  -ms-flex-align: center;
  align-items: center;
  padding-top: 40px;
  padding-bottom: 40px;
  background-color: #f5f5f5;
}

.form-signin {
  width: 100%;
  max-width: 330px;
  padding: 15px;
  margin: auto;
}
.form-signin .checkbox {
  font-weight: 400;
}
.form-signin .form-control {
  position: relative;
  box-sizing: border-box;
  height: auto;
  padding: 10px;
  font-size: 16px;
}
.form-signin .form-control:focus {
  z-index: 2;
}
.form-signin input[type='email'] {
  margin-bottom: -1px;
  border-bottom-right-radius: 0;
  border-bottom-left-radius: 0;
}
.form-signin input[type='password'] {
  margin-bottom: 10px;
  border-top-left-radius: 0;
  border-top-right-radius: 0;
}

app.module.ts
Incluir InicioModule en sección imports

Desarrollamos el guard par controlar los accesos

auth-guard.service.ts 

import { Injectable } from '@angular/core';
import { Router } from '@angular/router';
import { ILoginResponse } from '../interfaces/login.interface';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard {
  constructor(private router: Router) {}

  isLoggedIn() {
    const user = localStorage.getItem('usuario');
    if (user) {
      return true;
    }

    this.router.navigate(['login']);
    return false;
  }

  getUser(): string {
    const infoUser = localStorage.getItem('usuario');
    if (infoUser) {
      const userInfo: ILoginResponse = JSON.parse(infoUser);
      return userInfo.email;
    }
    return '';
  }

  getToken(): string {
    const infoUser = localStorage.getItem('usuario');
    if (infoUser) {
      const userInfo: ILoginResponse = JSON.parse(infoUser);
      return userInfo.token;
    }
    return '';
  }
}

Implementampos el guard en el sistema de rutas para impedir accesos no autorizados

app-routing.module.ts

import { NgModule, inject } from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
import { LoginComponent } from './inicio/login/login.component';
import { NotFoundComponent } from './inicio/not-found/not-found.component';
import { AuthGuard } from './guards/auth-guard.service';

export const canActivate = (authGuard = inject(AuthGuard)) => authGuard.isLoggedIn();

const appRoutes: Routes = [
  { path: '', redirectTo: '/login', pathMatch: 'full' },
  { path: 'login', component: LoginComponent },
  {
    path: 'almacen',
    loadChildren: () => import('./almacen/almacen.module').then((m) => m.AlmacenModule),
    canActivate: [() => canActivate()]
  },
  { path: '**', component: NotFoundComponent }
];

@NgModule({
  imports: [RouterModule.forRoot(appRoutes)],
  exports: [RouterModule]
})
export class AppRoutingModule {}


Creamos nuevo módulo Shared para el navbar

ng g m shared
ng g c shared/navbar --skip-tests=true

navbar.component.html 

<nav class="navbar navbar-expand-lg navbar-light bg-light">
  <div class="container-fluid">
    <a class="navbar-brand" routerLink="categorias">Almacén</a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent"
      aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav me-auto my-2 my-lg-0 navbar-nav-scroll" style="--bs-scroll-height: 100px;">
        <li class="nav-item active">
          <a class="nav-link" routerLink="/almacen/categorias" routerLinkActive="active">Categorías</a>
        </li>
        <li class="nav-item active">
          <a class="nav-link" routerLink="/almacen/productos" routerLinkActive="active">Productos</a>
        </li>
      </ul>
      <div class="d-flex">
        <p class="me-2 mt-2">Bienvenido, <b>{{userName}}</b></p>
        <button class="btn btn-outline-success" type="button" (click)="cerrarSesion()">Cerrar sesión</button>
      </div>
    </div>
  </div>
</nav>


navbar.component.ts

import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { AuthGuard } from 'src/app/guards/auth-guard.service';

@Component({
  selector: 'app-navbar',
  templateUrl: './navbar.component.html',
  styleUrls: ['./navbar.component.css']
})
export class NavbarComponent {
  userName = '';
  constructor(private authGuard: AuthGuard, private router: Router) {}

  ngOnInit(): void {
    this.userName = this.authGuard.getUser();
  }

  cerrarSesion() {
    localStorage.removeItem('usuario');
    this.router.navigateByUrl('/login');
  }
}

Incluimos el navbar en el almacén
almacen.component.html

En el módulo shared exportamos el navbar para poder utilizar este componente en almaén

shared.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NavbarComponent } from './navbar/navbar.component';
import { RouterModule } from '@angular/router';

@NgModule({
  declarations: [NavbarComponent],
  imports: [CommonModule, RouterModule],
  exports: [NavbarComponent]
})
export class SharedModule {}

En el módulo de almacen incluimos el sharedmodule

almacen.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { AlmacenComponent } from './almacen.component';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenRoutingModule } from './almacen-routing.module';
import { AlmacenService } from './almacen.service';
import { SharedModule } from '../shared/shared.module';


@NgModule({
  declarations: [
    AlmacenComponent,
    CategoriasComponent,
    ProductosComponent
  ],
  imports: [
    CommonModule,
    AlmacenRoutingModule,
    SharedModule
  ],
  providers:[AlmacenService]
})
export class AlmacenModule { }

En el componente login hacemos mejoras para no dejar iniciar sesión a un usuario que ya tenga sesión iniciada

login.component.ts

import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { MessageService } from 'primeng/api';
import { AuthGuard } from 'src/app/guards/auth-guard.service';
import { ILogin, ILoginResponse } from 'src/app/interfaces/login.interface';
import { AppService } from 'src/app/services/app.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css'],
  providers: [MessageService]
})
export class LoginComponent implements OnInit {
  infoLogin: ILogin = {
    email: '',
    password: ''
  };

  constructor(
    private router: Router,
    private appService: AppService,
    private messageService: MessageService,
    private authGuard: AuthGuard
  ) {}

  ngOnInit() {
    if (this.authGuard.isLoggedIn()) {
      this.router.navigateByUrl('almacen/categorias');
    }
  }

  login() {
    this.appService.login(this.infoLogin).subscribe({
      next: (data) => {
        // const infoUser: ILoginResponse = {
        //   email: data.email,
        //   token: data.token
        // };
        localStorage.setItem('usuario', JSON.stringify(data));
        //  this.router.navigateByUrl('almacen');
        this.router.navigate([`/almacen`], { replaceUrl: true });
      },
      error: (err) => {
        this.messageService.add({ severity: 'error', summary: 'Error', detail: 'Credenciales erróneas' });
      }
    });
  }
}

Creamos el archivo almacen.interface.ts

export interface IFamilia {
  id: number;
  nombre: string;
}



Desarrollamos el servicio de almacen

import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { Observable } from 'rxjs';
import { AuthGuard } from '../guards/auth-guard.service';
import { environment } from 'src/environments/environment';
import { IFamilia } from './almacen.interfaces';

@Injectable({
  providedIn: 'root'
})
export class AlmacenService {
  urlAPI = environment.urlAPI;
  constructor(private http: HttpClient, private authGuard: AuthGuard) {}

  getFamilias(): Observable<IFamilia[]> {
    const headers = this.getHeaders();
    return this.http.get<IFamilia[]>(`${this.urlAPI}familias`, { headers });
  }

  addFamilia(familia: IFamilia): Observable<IFamilia> {
    const headers = this.getHeaders();
    return this.http.post<IFamilia>(`${this.urlAPI}familias`, familia, { headers });
  }

  updateFamilia(familia: IFamilia): Observable<IFamilia> {
    const headers = this.getHeaders();
    return this.http.put<IFamilia>(`${this.urlAPI}familias`, familia, {
      headers
    });
  }

  deleteFamilia(id: number): Observable<IFamilia> {
    const headers = this.getHeaders();
    return this.http.delete<IFamilia>(`${this.urlAPI}familias/${id}`, {
      headers
    });
  }

  getHeaders(): HttpHeaders {
    const token = this.authGuard.getToken();
    const headers = new HttpHeaders({
      Authorization: `Bearer ${token}`
    });
    return headers;
  }
}



Modificamos el módulo de almacén con los módulos de Primeng y el módulo de formularios de Angular

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { DialogModule } from 'primeng/dialog';
import { TableModule } from 'primeng/table';
import { ButtonModule } from 'primeng/button';
import { ConfirmDialogModule } from 'primeng/confirmdialog';
import { AlmacenComponent } from './almacen.component';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenRoutingModule } from './almacen-routing.module';
import { AlmacenService } from './almacen.service';
import { SharedModule } from '../shared/shared.module';

@NgModule({
  declarations: [AlmacenComponent, CategoriasComponent, ProductosComponent],
  imports: [
    SharedModule,
    CommonModule,
    AlmacenRoutingModule,
    FormsModule,
    DialogModule,
    TableModule,
    ButtonModule,
    ConfirmDialogModule
  ],
  providers: [AlmacenService]
})
export class AlmacenModule {}


Seguimos con el componente de categorias

categorias.component.html

<div class="row mt-4">
    <div class="col-4">
      <h1>Agregar categoría</h1>
      <form #formulario="ngForm" (submit)="guardar()">
          <div class="form-group">
          <label for="nombre">Nombre</label>
          <input type="text" class="form-control" name="nombre" [(ngModel)]="familia.nombre" required #nombre="ngModel"
            id="nombre" placeholder="Nombre obligatorio" />
          <span class="form-text text-danger" *ngIf="!nombre.valid && nombre.touched">
            Nombre obligatorio
          </span>
        </div>
        <button type="submit" class="btn btn-primary" [disabled]="formulario.invalid">
          Aceptar
        </button>
        <button type="button" class="btn btn-warning" *ngIf="familia.id!==0" (click)="cancelarEdicion()">
          Cancelar edición
        </button>
      </form>
    </div>
    <div class="col-8">
      <p-table [value]="familias" [paginator]="true" [rows]="5" [showCurrentPageReport]="true"
        [tableStyle]="{ 'min-width': '50rem' }"
        currentPageReportTemplate="{first} de {last} de un total de {totalRecords} categorías"
        [rowsPerPageOptions]="[10, 25, 50]">
        <ng-template pTemplate="header">
          <tr>
            <th>Nombre</th>
            <th></th>
          </tr>
        </ng-template>
        <ng-template pTemplate="body" let-familia>
          <tr>
            <td>{{ familia.nombre }}</td>
            <td><p-button icon="pi pi-pencil" (click)="edit(familia)"
                styleClass="p-button-rounded p-button-warning"></p-button>
              <p-button icon="pi pi-trash" (click)="confirmDelete(familia)"
                styleClass="p-button-rounded p-button-danger"></p-button>
            </td>
          </tr>
        </ng-template>
      </p-table>
      <p-confirmDialog></p-confirmDialog>
      <p-dialog header="Alerta" [(visible)]="visibleError" [style]="{width: '50vw'}">
        <p>
          {{mensajeError}}
        </p>
      </p-dialog>
    </div>
  </div>

  

categorias.component.ts

import { Component, OnInit, ViewChild } from '@angular/core';
import { AlmacenService } from '../almacen.service';
import { NgForm } from '@angular/forms';
import { ConfirmationService } from 'primeng/api';
import { IFamilia } from '../almacen.interfaces';

@Component({
  selector: 'app-categorias',
  templateUrl: './categorias.component.html',
  styleUrls: ['./categorias.component.css'],
  providers: [ConfirmationService]
})
export class CategoriasComponent implements OnInit {
  constructor(private almacenService: AlmacenService, private confirmationService: ConfirmationService) {}
  @ViewChild('formulario') formulario!: NgForm;
  visibleError = false;
  mensajeError = '';
  familias: IFamilia[] = [];
  visibleConfirm = false;

  familia: IFamilia = {
    id: 0,
    nombre: ''
  };

  ngOnInit(): void {
    this.getFamilias();
  }

  getFamilias() {
    this.almacenService.getFamilias().subscribe({
      next: (data) => {
        console.log(data);
        this.visibleError = false;
        this.familias = data;
      },
      error: (err) => {
        this.visibleError = true;
        this.mensajeError = 'Se ha producido un erro en la carga de familias';
      }
    });
  }

  guardar() {
    if (this.familia.id === 0) {
      this.almacenService.addFamilia(this.familia).subscribe({
        next: (data) => {
          this.visibleError = false;
          this.formulario.reset();
          this.getFamilias();
        },
        error: (err) => {
          console.log(err);
          this.visibleError = true;
          this.mensajeError = err.error.msg;
        }
      });
    } else {
      this.almacenService.updateFamilia(this.familia).subscribe({
        next: (data) => {
          this.visibleError = false;
          this.cancelarEdicion();
          this.formulario.reset();
          this.getFamilias();
        },
        error: (err) => {
          this.visibleError = true;
          this.mensajeError = err.error.msg;
        }
      });
    }
  }

  edit(familia: IFamilia) {
    this.familia = { ...familia };
  }

  cancelarEdicion() {
    this.familia = {
      id: 0,
      nombre: ''
    };
  }

  confirmDelete(familia: IFamilia) {
    this.confirmationService.confirm({
      message: `Eliminar la categoría ${familia.nombre}?`,
      header: 'Estás seguro?',
      icon: 'pi pi-exclamation-triangle',
      acceptLabel: 'Sí',
      acceptButtonStyleClass: 'p-button-danger',
      accept: () => this.deleteFamilia(familia.id)
    });
  }

  deleteFamilia(id: number) {
    this.almacenService.deleteFamilia(id).subscribe({
      next: (data) => {
        this.visibleError = false;
        this.formulario.reset({
          nombre: ''
        });
        this.getFamilias();
      },
      error: (err) => {
        this.visibleError = true;
        this.mensajeError = 'Se ha producido un error';
      }
    });
  }
}


Productos

Creamos la clase DTOProducto

    public class DTOProducto
    {
        public int Id { get; set; }
        public string Nombre { get; set; } = null!;
        public decimal Precio { get; set; }
        public bool Descatalogado { get; set; }
        public string? FotoUrl { get; set; }
        public int FamiliaId { get; set; }
        public string Familia { get; set; }
    }

A continuación, agregamos la get de productos en el controller de productos

[HttpGet]
  public async Task<ActionResult> GetProductos()
  {
      var productos = await _context.Productos.Select(x => new DTOProducto
      {
          Id = x.Id,
          Nombre = x.Nombre,
          Precio = x.Precio,
          Descatalogado = x.Descatalogado,
          FotoUrl = x.FotoUrl,
          FamiliaId = x.FamiliaId,
          Familia = x.Familia.Nombre
      }).ToListAsync();

      return Ok(productos);
  }

  Proyecto Angular
  En almacen.interface.ts agregamos la interface de productos

  export interface IProducto {
  id: number;
  nombre: string;
  precio: number;
  descatalogado: boolean;
  foto?: File | null;
  fotoUrl?: string;
  familiaId: number | null;
  familia?: { nombre: string };
}

En almacen.service.ts, agregamos las peticiones para productos

  getProductos(): Observable<IProducto[]> {
    const headers = this.getHeaders();
    return this.http.get<IProducto[]>(`${this.urlAPI}Productos`, { headers });
  }

  addProducto(producto: IProducto): Observable<IProducto> {
    const headers = this.getHeaders();
    const formData = new FormData();
    formData.append('nombre', producto.nombre);
    formData.append('precio', producto.precio.toString());
    formData.append('familiaId', producto.familiaId?.toString()!);
    formData.append('descatalogado', producto.descatalogado ? 'true' : 'false');
    formData.append('foto', producto.foto!);

    return this.http.post<IProducto>(`${this.urlAPI}Productos`, formData, { headers });
  }

  deleteProducto(id: number): Observable<IProducto> {
    const headers = this.getHeaders();
    return this.http.delete<IProducto>(`${this.urlAPI}Productos/${id}`, {
      headers
    });
  }

  Desarrollamos el componente productos

  productos.component.ts

  import { Component, OnInit, ViewChild } from '@angular/core';
import { AlmacenService } from '../almacen.service';
import { ConfirmationService } from 'primeng/api';
import { NgForm } from '@angular/forms';
import { IFamilia, IProducto } from '../almacen.interfaces';

@Component({
  selector: 'app-productos',
  templateUrl: './productos.component.html',
  styleUrls: ['./productos.component.css'],
  providers: [ConfirmationService]
})
export class ProductosComponent implements OnInit {
  constructor(private almacenService: AlmacenService, private confirmationService: ConfirmationService) {}
  @ViewChild('formulario') formulario!: NgForm;
  visibleError = false;
  mensajeError = '';
  productos: IProducto[] = [];
  categorias: IFamilia[] = [];
  visibleConfirm = false;
  urlImagen = '';
  visibleFoto = false;
  foto = '';

  producto: IProducto = {
    id: 0,
    nombre: '',
    precio: 0,
    foto: null,
    descatalogado: false,
    familiaId: null
  };

  ngOnInit(): void {
    this.getCategorias();
    this.getProductos();
  }

  getCategorias() {
    this.almacenService.getFamilias().subscribe({
      next: (data) => {
        this.visibleError = false;
        this.categorias = data;
      },
      error: (err) => {
        this.visibleError = true;
        this.mensajeError = 'Se ha producido un erro en la carga de familias';
      }
    });
  }

  getProductos() {
    this.almacenService.getProductos().subscribe({
      next: (data) => {
        this.visibleError = false;
        this.productos = data;
        console.log(this.productos);
      },
      error: (err) => {
        this.visibleError = true;
        this.mensajeError = 'Se ha producido un erro en la carga de productos';
      }
    });
  }

  onChange(event: any) {
    const file = event.target.files;

    if (file) {
      this.producto.foto = file[0];
    }
  }

  showImage(producto: IProducto) {
    this.foto = producto.fotoUrl!;
    this.visibleFoto = true;
  }

  guardar() {
    this.almacenService.addProducto(this.producto).subscribe({
      next: (data: any) => {
        this.visibleError = false;
        this.formulario.reset();
        this.getProductos();
      },
      error: (err: any) => {
        this.visibleError = true;
        this.mensajeError = err.error.msg;
      }
    });
  }

  confirmDelete(producto: IProducto) {
    this.confirmationService.confirm({
      message: `Eliminar el producto ${producto.nombre}?`,
      header: 'Estás seguro?',
      icon: 'pi pi-exclamation-triangle',
      acceptLabel: 'Sí´',
      acceptButtonStyleClass: 'p-button-danger',
      accept: () => this.deleteProducto(producto.id)
    });
  }

  deleteProducto(id: number) {
    this.almacenService.deleteProducto(id).subscribe({
      next: (data: IProducto) => {
        this.visibleError = false;
        this.getProductos();
      },
      error: (err: any) => {
        this.visibleError = true;
        this.mensajeError = err.error.msg;
      }
    });
  }
}


  productos.component.html

  <div class="row mt-4">
  <div class="col-4">
    <h1>Agregar producto</h1>
    <form #formulario="ngForm" (submit)="guardar()">
      <div class="form-group">
        <label for="descripcion">Descripción</label>
        <input type="text" class="form-control" name="descripcion" [(ngModel)]="producto.nombre" required
          id="descripcion" #descripcion="ngModel" placeholder="Descripción obligatoria" />
        <span class="form-text text-danger" *ngIf="!descripcion.valid && descripcion.touched">
          Descripción obligatoria
        </span>
      </div>
      <div class="form-group">
        <label for="precio">Precio</label>
        <input type="number" class="form-control" name="precio" [(ngModel)]="producto.precio" required min="0"
          id="precio" #precio="ngModel" placeholder="Precio obligatorio" />
        <span class="form-text text-danger" *ngIf="!precio.valid && precio.touched">
          Precio obligatorio
        </span>
      </div>
      <div class="form-check">
        <input class="form-check-input" type="checkbox" [(ngModel)]="producto.descatalogado" id="descatalogado"
          name="descatalogado">
        <label class="form-check-label" for="descatalogado">
          Descatalogado
        </label>
      </div>
      <div class="form-group">
        <label for="categoria">Categoría</label>
        <select class="form-select" [(ngModel)]="producto.familiaId" name="categoria" required Id="categoria">
          <option value="null">Selecciona una categoría</option>
          <option *ngFor="let categoria of categorias" [value]="categoria.id">{{categoria.nombre}}
          </option>
        </select>
      </div>
      <div class="mt-3">
        <label for="imagen" class="form-label">Elegir imagen</label>
        <input class="form-control" type="file" id="imagen" (change)="onChange($event)" accept="image/*" />
      </div>
      <button type="submit" class="btn btn-primary" [disabled]="formulario.invalid">
        Aceptar
      </button>
    </form>
  </div>
  <div class="col-8">
    <p-table [value]="productos" [paginator]="true" [rows]="5" [showCurrentPageReport]="true"
      [tableStyle]="{ 'min-width': '50rem' }"
      currentPageReportTemplate="{first} de {last} de un total de {totalRecords} productos"
      [rowsPerPageOptions]="[10, 25, 50]">
      <ng-template pTemplate="header">
        <tr>
          <th>Nombre</th>
          <th>Precio</th>
          <th>Descatalogado</th>
          <th>Categoría</th>
          <th></th>
        </tr>
      </ng-template>
      <ng-template pTemplate="body" let-producto>
        <tr>
          <td>{{ producto.nombre }}</td>
          <td>{{ producto.precio | number : '1.2-2' }} </td>
          <td>{{ producto.Descatalogado ?'Sí':'No' }}</td>
          <td>{{ producto.familia }}</td>
          <td>
            <p-button icon="pi pi-trash" (click)="confirmDelete(producto)"
              styleClass="p-button-rounded p-button-danger"></p-button>
            <p-button icon="pi pi-eye" (click)="showImage(producto)"
              styleClass="p-button-rounded p-button-primary"></p-button>
          </td>
        </tr>
      </ng-template>
    </p-table>
    <p-confirmDialog></p-confirmDialog>
    <p-dialog header="Alerta" [(visible)]="visibleError" [style]="{width: '50vw'}">
      <p>
        {{mensajeError}}
      </p>
    </p-dialog>
    <p-dialog header="Foto" [(visible)]="visibleFoto" [style]="{width: '50vw'}">
     <img [src]="foto" alt="Foto del producto" class="img-fluid">
    </p-dialog>
  </div>
</div>


  Agregamos en program el middleware para ver archivos estáticos para poder así tener acceso a las imágenes

  app.UseStaticFiles();

  NUEVO SERVICIO PARA TESTING

  En la carpeta services, creamos la clase CalculosService
  CalculosService.cs

   public class CalculosService
    {
        public decimal CalculoIVA(decimal importe, bool reducido)
        {
            if (reducido)
            {
                return importe * 0.10m;
            }
            else
            {
                return importe * 0.21m; ;
            }
        }
    }

Registramos el servicio en el Program

builder.Services.AddTransient<CalculosService>();

Aumentar la inyección de dependencia en el controller de Productos para usar el nuevo servicio


        private readonly MiAlmacenContext context;
        private readonly OperacionesService operacionesService;
        private readonly IGestorArchivos gestorArchivosLocal;
        private readonly CalculosService calculosService;

        public ProductosController(MiAlmacenContext context,OperacionesService operacionesService, IGestorArchivos gestorArchivosLocal, CalculosService calculosService)
        {
            this.context = context;
            this.operacionesService = operacionesService;
            this.gestorArchivosLocal = gestorArchivosLocal;
            this.calculosService = calculosService;
        }

Agregar un get para probar el servicio (agregar a ProductosController)

 // Get para calcular el iva mediante CalculosService que
 // irá testeado en un proyecto de testing
 [HttpGet("iva/{id}/{reducido}")] 
 public async Task<ActionResult> GetProductoIVA(int id, bool reducido)
 {
     var producto = await context.Productos.FindAsync(id);
     var iva = calculosService.CalculoIVA(producto.Precio, reducido);
     return Ok(iva);
 }

 Agregamos a la solución un nuevo proyecto de tipo MSTest llamado WebAPIAlmacen.Tests
 Borramos la clase de prueba que se crea de forma automática.
 Agregamos una referencia al proyecto WebAPIAlmacen
 Creamos la carpeta Services y dentro creamos la clase CalculosServiceTests

 CalculosServiceTests.cs

     [TestClass]
    public class CalculosServiceTests
    {
        [TestMethod]
        public void IvaReducidoCalculaBien()
        {
            // Preparación
            var ivaService = new CalculosService();

            // Ejecución
            var iva = ivaService.CalculoIVA(1000,false);

            // Verificación. Assert permite hacer verificaciones
            Assert.AreEqual(210, iva);
        }

        [TestMethod]
        public void IvaGeneralCalculaBien()
        {
            // Preparación
            var ivaService = new CalculosService();

            // Ejecución
            var iva = ivaService.CalculoIVA(1000, true);

            // Verificación. Assert permite hacer verificaciones
            Assert.AreEqual(100, iva);
        }
    }

Desarrollamos un validador para obligar a introducir el primer carácter de un string en mayúsculas

En carpeta Validators creamos la clase PrimeraMayusculaAttribute

PrimeraMayusculaAttribute.cs

 public class PrimeraMayusculaAttribute : ValidationAttribute
    {
        // value sería el valor a validar
        protected override ValidationResult IsValid(object value, ValidationContext validationContext)
        {
            if (value is null)
            {
                return new ValidationResult("El valor no puede ser nulo");
            }
            var primeraLetra = value.ToString()[0].ToString();

            if (primeraLetra != primeraLetra.ToUpper())
            {
                return new ValidationResult("La primera letra debe ser mayúscula");
            }

            return ValidationResult.Success;
        }
    }

Aplicamos el validador al DTOFamilia

   public class DTOFamilia
    {
        public int Id { get; set; }
        [PrimeraMayusculaAttribute]
        public string Nombre { get; set; }
    }

En el proyecto WebAPIAlmacen.Tests creamos la carpeta Validators
Dentro, creamos la clase PrimeraMayusculaAttributeTests

PrimeraMayusculaAttributeTests.cs

 [TestClass]
    public class PrimeraMayusculaAttributeTests
    {
        [TestMethod]
        public void PrimeraLetraMinuscula_DevuelveError()
        {
            // Preparación
            var primeraLetraMayuscula = new PrimeraMayusculaAttribute();
            var valor = "juan luis";
            var valContext = new ValidationContext(new { Nombre = valor });

            // Ejecución
            var resultado = primeraLetraMayuscula.GetValidationResult(valor, valContext);

            // Verificación. Assert permite hacer verificaciones
            Assert.AreEqual("La primera letra debe ser mayúscula", resultado.ErrorMessage);
        }

        [TestMethod]
        public void ValorNulo_DevuelveError()
        {
            // Preparación
            var primeraLetraMayuscula = new PrimeraMayusculaAttribute();
            string valor = null;
            var valContext = new ValidationContext(new { Nombre = valor });

            // Ejecución. Si no hay errores retorna null
            var resultado = primeraLetraMayuscula.GetValidationResult(valor, valContext);

            // Verificación
            Assert.AreEqual("El valor no puede ser nulo", resultado.ErrorMessage);
        }

        [TestMethod]
        public void ValorConPrimeraLetraMayuscula_NoDevuelveError()
        {
            // Preparación
            var primeraLetraMayuscula = new PrimeraMayusculaAttribute();
            string valor = "Juan Luis";
            var valContext = new ValidationContext(new { Nombre = valor });

            // Ejecución
            var resultado = primeraLetraMayuscula.GetValidationResult(valor, valContext);

            // Verificación
       	    Assert.AreEqual(ValidationResult.Success, resultado);
        }
    }


--------------------------------------------------------------------------
AGREGAR SIGNALR EN EL PROYECTO
--------------------------------------------------------------------------
Creamos carpeta Hubs y dentro la clase MovimientosHub

Movimientoshub.cs

 public class MovimientosHub: Hub
    {
        public async Task SendMessage(string message)
        {
            await Clients.Others.SendAsync("GetMessage", message);
        }
    }


Program.cs

...

builder.Services.AddSignalR();

...

app.MapHub<MovimientosHub>("/movimientosHub");


Seguimos con proyecto Angular
Instalamos los paquetes de signalr

npm install @microsoft/signalr
npm install @types/signalr -save-dev

Creamos el servicio para conectarnos desde Angular

ng g s services/signalr --skip-tests=true

environment.ts/environment.Development.ts

export const environment = {
  urlAPI: 'https://localhost:44397/api/',
  urlSignalR: 'https://localhost:44397/movimientosHub'
};


signalr.service.ts

import { Injectable } from '@angular/core';
import * as signalR from '@microsoft/signalr';
import { Subject } from 'rxjs';
import { environment } from 'src/environments/environment';

@Injectable({
  providedIn: 'root'
})
export class SignalrService {
  urlSignalR = environment.urlSignalR;
  hubConnection!: signalR.HubConnection;
  messageSubscription: Subject<string> = new Subject<string>();
  connected = false;

  constructor() {
    this.configure();
  }

  configure() {
    if (!this.hubConnection) {
      this.hubConnection = new signalR.HubConnectionBuilder()
        .withUrl(this.urlSignalR, {
          skipNegotiation: true,
          transport: signalR.HttpTransportType.WebSockets,
        })
        .withAutomaticReconnect()
        .build();
    }
  }

  connect(){
    this.hubConnection
        .start()
        .then(() => {
          console.log('Connection started');
          this.connected = true;
          this.listenMessages();
        })
        .catch((err) => console.log('Error while starting connection: ' + err));
  }

  disconnect() {
    this.hubConnection?.stop().then(() => {
      console.log('Connection stopped');
      this.connected = false;
    }).catch((err) => console.log('Error while stopping connection: ' + err));
  }

  listenMessages() {
    this.hubConnection.on('GetMessage', (message: string) => {
      this.messageSubscription.next(message);
    });
  }

  sendMessage(message: string) {
    this.hubConnection.send('SendMessage', message);
  }
}

En el componente principal ponemos el componente que nos dice si estamos conectados o no

app.component.ts

import { Component } from '@angular/core';
import { SignalrService } from './services/signalr.service';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'AngularAlmacen';
  get connected() {
    return this.signalRService.connected;
  }

  constructor(private signalRService: SignalrService) {}
}

app.component.html

<footer>
    <div class="alert alert-success" role="alert" *ngIf="connected">
       Conectado al servicio de mensajes en tiempo real
      </div>
      <div class="alert alert-danger" role="alert" *ngIf="!connected">
        No conectado al servicio de mensajes en tiempo real
      </div>
</footer>


Nos conectamos al hub al iniciar sesión

login.component.ts

import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { MessageService } from 'primeng/api';
import { AuthGuard } from 'src/app/guards/auth-guard.service';
import { ILogin, ILoginResponse } from 'src/app/interfaces/login.interface';
import { AppService } from 'src/app/services/app.service';
import { SignalrService } from 'src/app/services/signalr.service';

@Component({
  selector: 'app-login',
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.css'],
  providers: [MessageService]
})
export class LoginComponent implements OnInit {
  infoLogin: ILogin = {
    email: '',
    password: ''
  };

  constructor(
    private router: Router,
    private appService: AppService,
    private messageService: MessageService,
    private authGuard: AuthGuard,
    private singalRService: SignalrService
  ) {}

  ngOnInit() {
    if (this.authGuard.isLoggedIn()) {
      this.router.navigateByUrl('almacen/categorias');
    }
  }

  login() {
    this.appService.login(this.infoLogin).subscribe({
      next: (data) => {
        console.log(data);
        localStorage.setItem('usuario', JSON.stringify(data));
        //  this.router.navigateByUrl('almacen');
        this.singalRService.connect();
        this.router.navigate([`/almacen`], { replaceUrl: true });
      },
      error: (err) => {
        console.log(err);
        this.messageService.add({ severity: 'error', summary: 'Error', detail: 'Credenciales erróneas' });
      }
    });
  }
}


Nos desconectamos al cerrar sesión

navbar.component.ts

import { Component } from '@angular/core';
import { Router } from '@angular/router';
import { AuthGuard } from 'src/app/guards/auth-guard.service';
import { SignalrService } from 'src/app/services/signalr.service';

@Component({
  selector: 'app-navbar',
  templateUrl: './navbar.component.html',
  styleUrls: ['./navbar.component.css']
})
export class NavbarComponent {
  userName = '';
  constructor(private authGuard: AuthGuard, private router: Router, private signalRService: SignalrService) {}

  ngOnInit(): void {
    this.userName = this.authGuard.getUser();
  }

  cerrarSesion() {
    localStorage.removeItem('usuario');
    this.signalRService.disconnect();
    this.router.navigateByUrl('/login');
  }
}


Al agregar una categoría, enviamos un mensaje al hub para el resto de usuarios. Preparamos también el componente de categorías para recibir mensajes

En el módulo de almacén incluimos el toast de PrimeNG para los mensajes

almacen.module.ts

import { NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { DialogModule } from 'primeng/dialog';
import { TableModule } from 'primeng/table';
import { ButtonModule } from 'primeng/button';
import { ConfirmDialogModule } from 'primeng/confirmdialog';
import { AlmacenComponent } from './almacen.component';
import { CategoriasComponent } from './categorias/categorias.component';
import { ProductosComponent } from './productos/productos.component';
import { AlmacenRoutingModule } from './almacen-routing.module';
import { AlmacenService } from './almacen.service';
import { SharedModule } from '../shared/shared.module';
import { ToastModule } from 'primeng/toast';

@NgModule({
  declarations: [AlmacenComponent, CategoriasComponent, ProductosComponent],
  imports: [
    SharedModule,
    CommonModule,
    AlmacenRoutingModule,
    FormsModule,
    DialogModule,
    TableModule,
    ButtonModule,
    ConfirmDialogModule,
    ToastModule
  ],
  providers: [AlmacenService]
})
export class AlmacenModule {}


Ahora vamos con el componente de categorias

categorias.component.ts

import { Component, OnInit, ViewChild } from '@angular/core';
import { AlmacenService } from '../almacen.service';
import { NgForm } from '@angular/forms';
import { ConfirmationService, MessageService } from 'primeng/api';
import { IFamilia } from '../almacen.interfaces';
import { SignalrService } from 'src/app/services/signalr.service';
import { AuthGuard } from 'src/app/guards/auth-guard.service';

@Component({
  selector: 'app-categorias',
  templateUrl: './categorias.component.html',
  styleUrls: ['./categorias.component.css'],
  providers: [ConfirmationService, MessageService]
})
export class CategoriasComponent implements OnInit {
  constructor(
    private almacenService: AlmacenService,
    private confirmationService: ConfirmationService,
    private signalrService: SignalrService,
    private messageService: MessageService,
    private authGuard: AuthGuard
  ) {}

  @ViewChild('formulario') formulario!: NgForm;
  visibleError = false;
  mensajeError = '';
  familias: IFamilia[] = [];
  visibleConfirm = false;

  familia: IFamilia = {
    id: 0,
    nombre: ''
  };

  ngOnInit(): void {
    this.getMessages();
    this.getFamilias();
  }

  getMessages() {
    this.signalrService.messageSubscription.subscribe({
      next: (message) => {
        this.messageService.add({ severity: 'info', summary: 'Alerta', detail: message });
        this.getFamilias();
      }
    });
  }

  getFamilias() {
    this.almacenService.getFamilias().subscribe({
      next: (data) => {
        console.log(data);
        this.visibleError = false;
        this.familias = data;
      },
      error: (err) => {
        this.controlarError(err);
      }
    });
  }

  guardar() {
    if (this.familia.id === 0) {
      this.almacenService.addFamilia(this.familia).subscribe({
        next: (data) => {
          this.visibleError = false;
          this.getFamilias();
          this.signalrService.sendMessage(this.authGuard.getUser() + ' ha agregado la familia ' + this.familia.nombre);
          this.formulario.reset();
        },
        error: (err) => {
          this.controlarError(err);
        }
      });
    } else {
      this.almacenService.updateFamilia(this.familia).subscribe({
        next: (data) => {
          this.visibleError = false;
          this.cancelarEdicion();
          this.formulario.reset();
          this.getFamilias();
        },
        error: (err) => {
          this.controlarError(err);
        }
      });
    }
  }

  edit(familia: IFamilia) {
    this.familia = { ...familia };
  }

  cancelarEdicion() {
    this.familia = {
      id: 0,
      nombre: ''
    };
  }

  confirmDelete(familia: IFamilia) {
    this.confirmationService.confirm({
      message: `Eliminar la categoría ${familia.nombre}?`,
      header: '¿Estás seguro?',
      icon: 'pi pi-exclamation-triangle',
      acceptLabel: 'Sí',
      acceptButtonStyleClass: 'p-button-danger',
      accept: () => this.deleteFamilia(familia.id!)
    });
  }

  deleteFamilia(id: number) {
    this.almacenService.deleteFamilia(id).subscribe({
      next: (data) => {
        this.visibleError = false;
        this.formulario.reset({
          nombreFamilia: ''
        });
        this.getFamilias();
      },
      error: (err) => {
        this.controlarError(err);
      }
    });
  }

  controlarError(err: any) {
    this.visibleError = true;
    if (err.error && typeof err.error === 'object' && err.error.message) {
      this.mensajeError = err.error.message;
    } else if (typeof err.error === 'string') {
      // Si `err.error` es un string, se asume que es el mensaje de error
      this.mensajeError = err.error;
    } else {
      // Maneja el caso en el que no se recibe un mensaje de error útil
      this.mensajeError = 'Se ha producido un error inesperado';
    }
  }
}


En el html solo agregamos al final el toast

categorias.component.html

...

<p-toast></p-toast>






